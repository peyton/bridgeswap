// SPDX-License-Identifier: Unlicense
pragma soliditypp >=0.4.3;


contract Bridgeswap {

  struct Pair {
    bool initialized;

    tokenId tokenA;
    tokenId tokenB;

    uint256 supplyA;
    uint256 supplyB;

    uint256 totalPoolSupply;
    mapping(address => uint256) poolBalances;
  }

  struct PairFlag {
    tokenId tokenA;
    tokenId tokenB;
  }

  // --------------------
  // Events
  // --------------------

  event AddLiquidity(
    address indexed provider,
    tokenId indexed tokenAId,
    uint256 tokenAAmount,
    tokenId indexed tokenBId,
    uint256 tokenBAmount
  );
  event ChangeOwner(
    address indexed newOwner
  );
  event Deposit(
    address indexed provider,
    tokenId indexed tokenid,
    uint256 amount
  );
  event RemoveLiquidity(
    address indexed provider,
    tokenId indexed tokenAId,
    uint256 tokenAAmount,
    tokenId indexed tokenBId,
    uint256 tokenBAmount
  );
  event Swap(
    address indexed destination, 
    tokenId indexed tokenSold, 
    uint256 amountSold,
    tokenId indexed tokenBought, 
    uint256 amountBought
  );
  event Withdrawal(
    address indexed provider,
    tokenId indexed tokenid,
    uint256 amounta
  );

  // --------------------
  // State
  // --------------------

  address public owner;

  mapping(tokenId => mapping(tokenId => Pair)) pairs;
  PairFlag[] pairFlags;

  mapping(address => mapping(tokenId => uint256)) holdingPool;

  // --------------------
  // 
  // --------------------

  constructor() {
    owner = msg.sender;
  }

  // --------------------
  // Owned
  // --------------------

  onMessage changeOwner(address _newOwner) {
      require(msg.sender == owner && _newOwner != owner);
      owner = _newOwner;
      emit ChangeOwner(_newOwner);
  }

  // --------------------
  // Pairs
  // --------------------

  onMessage addPair(tokenId _tokenAIn, tokenId _tokenBIn) {
    require(msg.sender == owner);
    (tokenId _tokenA, tokenId _tokenB) = canonicalizePair(_tokenAIn, _tokenBIn);
    Pair storage _pair = pairs[_tokenA][_tokenB];
    require(!_pair.initialized);

    _pair.initialized = true;
    _pair.tokenA = _tokenA;
    _pair.tokenB = _tokenB;
    
    pairFlags.push(PairFlag({
      tokenA: _tokenA, 
      tokenB: _tokenB}
    ));
  }

  function canonicalizePair(tokenId _tokenA, tokenId _tokenB) private pure returns (tokenId, tokenId) {
    require(_tokenA != _tokenB);
    
    if (_tokenA < _tokenB) {
      return (_tokenA, _tokenB);
    } else {
      return (_tokenB, _tokenA);
    }
  }

  // --------------------
  // Liquidity
  // --------------------

  getter getHoldingPoolBalance(address _address, tokenId _token) view returns (uint256) {
    return holdingPool[_address][_token];
  }

  onMessage deposit() payable {
    require(msg.amount > 0);
    holdingPool[msg.sender][msg.tokenid] += msg.amount;
    emit Deposit(msg.sender, msg.tokenid, msg.amount);
  }

  onMessage withdraw(uint256 _amount, tokenId _token) {
    uint256 _senderBalance = holdingPool[msg.sender][_token];
    require(_amount <= _senderBalance);
    holdingPool[msg.sender][_token] -= _amount;
    msg.sender.transfer(_token, _amount);
    emit Withdrawal(msg.sender, _token, _amount);
  }

  // --------------------
  // Swapping
  // --------------------

  // @dev Pricing function for converting between token A and token B
  // @param input_amount Amount of token A or token B being sold.
  // @param input_reserve Amount of token A or token B (input type) in exchange reserves.
  // @param output_reserve Amount of token A or token B (output type) in exchange reserves.
  // @return Amount of token A or token B bought.
  function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) private pure returns (uint256) {
    uint256 input_amount_with_fee = input_amount * 997;
    uint256 numerator = input_amount_with_fee * output_reserve;
    uint256 denominator = (input_reserve * 1000) + input_amount_with_fee;
    return numerator / denominator;
  }

  // @dev Pricing function for converting between token A and token B.
  // @param output_amount Amount of token A or token B being bought.
  // @param input_reserve Amount of token A or token B (input type) in exchange reserves.
  // @param output_reserve Amount of token A or token B (output type) in exchange reserves.
  // @return Amount of token A or token B sold.
  function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) private pure returns (uint256) {
    uint256 numerator = input_reserve * output_amount * 1000;
    uint256 denominator = (output_reserve - output_amount) * 997;
    return numerator / denominator + 1;
  }

  // @notice Buy tokens
  // @dev User specifies exact input (msg.amount of msg.tokenId) and minimum output (slippage).
  // @param _outputTokenId Token to buy.
  // @param _minOutput Minimum tokens bought; fails if not met.
  // @param _deadline Height after which this swap can no longer be executed
  onMessage swapInput(tokenId _outputTokenId, uint256 _minOutput, uint256 _deadline) payable {
    require(height() <= deadline);
    // require(msg.tokenid == tokenA); // TODO: generalize

    // require(msg.tokenid == tokenA || msg.tokenid == tokenB);

    // uint256 tokenBBought = getInputPrice(msg.amount, supplyA, supplyB);
    // require(tokenBBought <= supplyB);
    // require(tokenBBought >= min_output);

    // supplyA += msg.amount;
    // supplyB -= tokenBBought;

    // msg.sender.transfer(tokenB, tokenBBought);

    // emit Swap(
    //   msg.sender,
    //   tokenA,
    //   msg.amount,
    //   tokenB,
    //   tokenBBought
    // );
  }

  // @notice Buy tokens
  // @dev User specifies maximum input (msg.amount of msg.tokenId) and exact output.
  // @param _outputTokenId Token to buy.
  // @param _numBought Amount of tokens bought.
  // @param _deadline Height after which this swap can no longer be executed
  onMessage swapOutput(tokenId _outputTokenId, uint256 _numBought, uint256 _deadline) payable {
    require(height() <= deadline);
    // require(msg.tokenid == tokenA); // TODO: generalize

    // require(msg.tokenid == tokenA || msg.tokenid == tokenB);

    // uint256 tokenASold = getOutputPrice(num_bought, supplyA, supplyB);
    // require(tokenASold <= msg.amount);
    // require(num_bought <= supplyB);

    // supplyA += tokenASold;
    // supplyB -= num_bought;

    // msg.sender.transfer(tokenA, msg.amount - tokenASold);
    // msg.sender.transfer(tokenB, num_bought);

    // emit Swap(
    //   msg.sender,
    //   tokenA,
    //   tokenASold,
    //   tokenB,
    //   num_bought
    // );
  }

  // --------------------
  // Utilities
  // --------------------

  function max(uint256 _a, uint256 _b) private pure returns (uint256) {
    return _a >= _b ? _a : _b;
  }

  function min(uint256 _a, uint256 _b) private pure returns (uint256) {
    return _a < _b ? _a : _b;
  }
}