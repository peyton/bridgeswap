pragma soliditypp >=0.4.3;

//import './interfaces/IBridgeswapV1Pair.solpp';

contract SinglePair {
    // Invariants - 
    // Symbol A < Symbol B (tbd method, maybe hash each token ID)

    tokenId constant ZERO_TOKEN_ID = tokenId("tti_000000000000000000004cfd");

    bytes32 name = "Bridgeswap SinglePair";
    uint256 decimals = 18;

    tokenId tokenA;
    tokenId tokenB;
    bool initialized = false;

    uint256 supplyA = 0;
    uint256 supplyB = 0;

    mapping(address => uint256) poolBalanceA;
    mapping(address => uint256) poolBalanceB;

    struct BankAccount { // Idk if we need the struct here, maybe there is more we can pack in here in the future though
        mapping(tokenId => uint256) account;
    }

    mapping(address => BankAccount) bankAccounts;
    getter supportedTokens()returns (tokenId, tokenId) {
        return (tokenA, tokenB);
    }

    onMessage initialize(tokenId _tokenA, tokenId _tokenB) {
        require(!initialized);
        initialized = true;
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    getter isinitialized()returns (bool) {
        return initialized;
    }

    // @dev Pricing function for converting between token A and token B
    // @param input_amount Amount of token A or token B being sold.
    // @param input_reserve Amount of token A or token B (input type) in exchange reserves.
    // @param output_reserve Amount of token A or token B (output type) in exchange reserves.
    // @return Amount of token A or token B bought.
    function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) private returns (uint256) {
        uint256 input_amount_with_fee = input_amount * 997;
        uint256 numerator = input_amount_with_fee * output_reserve;
        uint256 denominator = (input_reserve * 1000) + input_amount_with_fee;
        return numerator / denominator;
    }

    // @dev Pricing function for converting between token A and token B.
    // @param output_amount Amount of token A or token B being bought.
    // @param input_reserve Amount of token A or token B (input type) in exchange reserves.
    // @param output_reserve Amount of token A or token B (output type) in exchange reserves.
    // @return Amount of token A or token B sold.
    function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) private returns (uint256) {
        uint256 numerator = input_reserve * output_amount * 1000;
        uint256 denominator = (output_reserve - output_amount) * 997;
        return numerator / denominator + 1;
    }

    getter tokenBalance(address addr, tokenId token)returns (uint256) {
        return bankAccounts[addr].account[token];
    }

    onMessage deposit() payable {
        bankAccounts[msg.sender].account[msg.tokenid]+=msg.amount; 
    }

    onMessage withdraw(uint256 amount, tokenId token) {
        uint256 balance = bankAccounts[msg.sender].account[token];
        require(amount <= balance);
        bankAccounts[msg.sender].account[token] = balance - amount;
        msg.sender.transfer(token, amount);
    }

    onMessage addLiquidity(uint256 amountTokenA, uint256 amountTokenB) {
        // TODO: Need to implement swap fee 
        uint256 balanceA = bankAccounts[msg.sender].account[tokenA];
        uint256 balanceB = bankAccounts[msg.sender].account[tokenB];

        require((amountTokenA <= balanceA) && (amountTokenB <= balanceB));
        // Update pool balances
        poolBalanceA[msg.sender] += amountTokenA;
        poolBalanceB[msg.sender] += amountTokenB;

        // Remove amounts from bank balance
        bankAccounts[msg.sender].account[tokenA] = balanceA - amountTokenA;
        bankAccounts[msg.sender].account[tokenB] = balanceB - amountTokenB;

        // Increment overall supply
        supplyA += amountTokenA;
        supplyB += amountTokenB;
    }

    onMessage removeLiquidity(uint256 amountTokenA, uint256 amountTokenB) {
        require((amountTokenA <= poolBalanceA[msg.sender]) && (amountTokenB <= poolBalanceB[msg.sender]));

        // Remove from pool
        poolBalanceA[msg.sender] -= amountTokenA;
        poolBalanceB[msg.sender] -= amountTokenB;

        // Remove from supply
        supplyA -= amountTokenA;
        supplyB -= amountTokenB;

        // Return tokens to wallet
        msg.sender.transfer(tokenA, amountTokenA);
        msg.sender.transfer(tokenB, amountTokenB);
    }
}